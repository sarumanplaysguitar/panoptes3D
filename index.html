<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>panoptes3D (Demo)</title>
  <style>
    html {
      box-sizing: border-box;
    }

    /* *,
    *:before,
    *:after {
      box-sizing: inherit;
      overflow: hidden;
    } */

    body {
      margin: 0;
      background: #3A3A3A;
      box-sizing: inherit;
      overflow: hidden;
    }

    .frame {
      /* padding: 50px; */
      display: flex;
      width: 100vw;
      height: 100vh;
      /* box-sizing: inherit;
      overflow: hidden; */
    }

    .frame>* {
      flex: 1 1 100%;
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>

  <div class="frame">
    <div class="container">
      <canvas></canvas>
    </div>
  </div>

  <script type="text/javascript" src="js/three.min.js"></script>
  <script type="text/javascript" src="js/OrbitControls.js"></script>
  <script type="text/javascript" src="js/GLTFLoader.js"></script>
  <script type="text/javascript" src="js/dat.gui.min.js"></script>
  <script type="text/javascript" src="js/RGBELoader.js"></script>
  <script type="text/javascript" src="https://unpkg.com/stats.js@0.17.0/build/stats.min.js"></script>
  <script type="text/javascript" src="data/mag_5_stars_copy.js"></script>

  <script type="text/javascript">

    console.log(`using three.js r${THREE.REVISION}`);

    const pi = Math.PI;

    function deg_to_rad(deg) {
      return deg * pi / 180;
    }

    // Astronomical positions and data 🌙
    // (get from API later)
    var sun_altitude = -10.;
    var prev_sun_altitude = -10.
    // stars data was imported from data/mag_5_stars.js in stars_arr
    console.log(stars_arr)


    // Shaders 🔮

    const stars_vshader = `
    attribute float size;
    // varying vec3 vColor;
    varying vec4 mvPosition;
    varying vec3 pos;
    varying vec4 glpos;
    // varying vec4 origin;
    varying vec4 glorigin;
    uniform vec4 origin;
    varying vec4 mv_origin;

    void main() {
      // vColor = color;
      pos = position;
      mvPosition = modelViewMatrix * vec4(position, 1.0);
      float camera_dist = distance(mvPosition, origin);
      gl_PointSize = size * clamp((7.0 / camera_dist), 0.5, 7.);
      gl_Position = projectionMatrix * mvPosition;
      glpos = gl_Position;
      mv_origin = modelViewMatrix * vec4(0., 0., 0., 1.0);
      glorigin = projectionMatrix * origin;
    }
    `

    const stars_fshader = `
    // varying vec3 vColor;
    varying vec4 mvPosition;
    varying vec3 pos;
    varying vec4 glpos;
    uniform vec4 origin;
    varying vec4 glorigin;
    varying vec4 mv_origin;

    void main(void) {
      // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      // gl_FragColor = vec4(vColor, 1.0);
      if ( mvPosition.z > mv_origin.z + (11.0 * (1. / length(mv_origin))) || pos.y < 0. + 0.2) {
        discard;
        }
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);

    }
    `
    const sky_vshader = `
    varying vec3 final_mix;
    uniform vec3 u_ground;
    uniform vec3 u_horizon;
    uniform vec3 u_low;
    uniform vec3 u_mid;
    uniform vec3 u_upper;
    uniform vec3 u_white;

    void main() {
      // Mix from the ground up.
      vec3 mix1 = mix(u_ground, u_horizon, smoothstep(0.5, 0.55, uv.y));
      vec3 mix2 = mix(mix1, u_low, smoothstep(0.5, 0.65, uv.y));
      vec3 mix3 = mix(mix2, u_mid, smoothstep(0.5, 0.8, uv.y));
      vec3 mix4 = mix(mix3, u_upper, smoothstep(0.7, 1., uv.y));

      final_mix = mix4;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
    `

    const sky_fshader = `
    varying vec3 final_mix;

    void main(void) {
      gl_FragColor = vec4(final_mix, 1.0);
    }
    `

    const ground_vshader = `
    varying vec2 v_uv;

    void main() {
      v_uv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
    `

    const ground_fshader = `
    uniform vec2 u_resolution;
    uniform vec3 u_ground_glow;
    varying vec2 v_uv;

    // Make opacity falloff as function of distance
    // Plane should be a solid color

    void main(void) {
      vec2 coords = v_uv - 0.5;
      vec3 color = u_ground_glow;
      float d = length(coords);

      // float t = 0.4;
      // float falloff = clamp(d, 0.0, t);
      // gl_FragColor = vec4(vec3(color), (t - falloff) * 2.);

      float falloff = 1.0 - smoothstep(0.0, 0.4, d);

      gl_FragColor = vec4(color, falloff);
    }
    `

    // FPS stats (by mrdoob) 📊

    var stats = new Stats();
    document.body.appendChild(stats.dom);
    requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) });


    // Camera settings 🎥

    const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector("canvas"), alpha: false, antialias: true, precision: "highp" });
    renderer.outputEncoding = THREE.sRGBEncoding;
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.5, 40);
    console.log(`focal length: ${Math.round(camera.getFocalLength())}`);
    camera.position.set(3, 0.6, 3);
    // camera.position.set(50, 3, 50);
    // controls = new THREE.PointerLockControls(camera, renderer.domElement);
    var controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0.5, 0);
    controls.enablePan = false;
    controls.minDistance = 1.5;
    controls.maxDistance = 30;
    controls.enableDamping = true;
    controls.dampingFactor = 0.15;
    controls.update();



    // Scene setup 🖼

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x00003f, 0, 20);
    scene.background = new THREE.Color(0x3A3A3A);
    // scene.fog = new THREE.Fog(0xffffff, 0, 5);



    // Lighting 💡

    const light1 = new THREE.PointLight(0xffcfa6, 0.2, 0);
    light1.position.set(10, 10, 10);
    scene.add(light1);

    const light2 = new THREE.PointLight(0xffcfa6, 0.1, 0);
    light2.position.set(-10, 10, -10);
    scene.add(light2);

    // var directionalLight = new THREE.DirectionalLight(0xffffff, 2);
    // scene.add(directionalLight);

    var ambient_light = new THREE.AmbientLight(0xbfa6ff, intensity = 0.5);
    scene.add(ambient_light);


    // Sun altitude



    // HDRI 🌇
    var pmremGenerator = new THREE.PMREMGenerator(renderer);
    new THREE.RGBELoader()
      .setDataType(THREE.UnsignedByteType)
      .setPath('assets/hdri/')
      .load('placeholder_sunset.hdr', function (texture) {

        var envMap = pmremGenerator.fromEquirectangular(texture).texture;
        pmremGenerator.compileCubemapShader();

        // scene.background = envMap;
        scene.environment = envMap;

        texture.dispose();
        pmremGenerator.dispose();

      });


    // Materials 🎨

    // Define from ground to zenith, to floor/ground highlight at last position
    // TODO: reorganize these later from zenith -> ground, and either bundle light + floor data in
    // with this, or separate all 3 of them
    const sky_colors = {
      day: [
        0x94cbfe,
        0xe3fbff,
        0xc5efff,
        0xb5e7ff,
        0x95cbff,
        0xb5e7ff
      ],
      green: [
        0x80bfff,
        0xc5eef3,
        0x9cdef7,
        0x78c1fd,
        0x77a8ff,
        0x9addfc
      ],
      green_golden: [
        0x5f9df3,
        0xad9ed6,
        0xe4ffee,
        0x6ccaff,
        0x5f9df3,
        0x7abfff
      ],
      golden: [
        0x4c61d1,
        0xcfbee8,
        0xbad5fd,
        0x5c76da,
        0x5c76da,
        0x6f84e3
      ],
      twilight: [
        0x27247b,
        0x7060ae,
        0x5659a2,
        0x2c368a,
        0x2a277d,
        0x36419c
      ],
      twilight_night: [
        0x00003f,
        0x101063,
        0x0a0a4f,
        0x050539,
        0x050539,
        0x0b0b52
      ],
      night: [
        0x00003f,
        0x0a0a4f,
        0x070744,
        0x050539,
        0x050539,
        0x0b0b52
      ],
      deep_night: [
        0x00003f,
        0x0a0a4f,
        0x070744,
        0x050539,
        0x050539,
        0x0b0b52
      ]
    };

    const ambient_light_colors = {
      day: 0xa6a9ff,
      green: 0xa6a9ff,
      green_golden: 0xa6a9ff,
      golden: 0xd7a6ff,
      twilight: 0xbfa6ff,
      twilight_night: 0x6947bf,
      night: 0x6947bf,
      deep_night: 0x6947bf
    }

    const sun_thresholds = [90, 50, -5, -10, -13, -16, -18, -90];

    function blend_sky_colors(sun_altitude, sun_thresholds, sky_colors) {
      // Returns array of linearly interpolated sky colors (one for each degree breakpoint in sun_thresholds)
      // based on sun's altitude, and blended from a few key, preset sky colors/edge cases (hex codes in sky_colors)
      var sky_color_lerp_array = [];
      var num_thresholds = sun_thresholds.length;
      // console.log(sky_colors);
      var num_colors = sky_colors['day'].length;
      var sky_colors_keys = Object.keys(sky_colors);

      // Determine what "time of day" it is by seeing which of the 2 thresholds sun_altitude is within
      for (let i = 0; i < num_thresholds; i++) {
        if (sun_altitude >= sun_thresholds[i]) {

          // ambient_light.color.set(ambient_light_colors[sky_colors_keys[i]]);
          // console.log(ambient_light_colors[i]);

          if (sun_altitude == sun_thresholds[i]) {
            // It's equal to an edge case, so nothing to interpolate - just return pre-made sky colors.
            // sky_color_lerp_array = sky_colors[sky_colors_keys[i]];
            for (let j = 0; j < num_colors; j++) {
              var key_color = new THREE.Color(sky_colors[sky_colors_keys[i]][j]);
              sky_color_lerp_array.push(key_color);

              // Update fog color if color calculated was ground (first entry in color table)
              if (j == 0) scene.fog.color = key_color;
              if (j == 0) ambient_light.color.set(key_color);
            }
          } else {
            // Need to interpolate between 2 thresholds, in order of day -> night (or, higher sun altitude -> lower)
            var upper_threshold = sun_thresholds[i - 1];
            var lower_threshold = sun_thresholds[i];

            var percent = Math.round(((upper_threshold - sun_altitude) / (upper_threshold - lower_threshold) + 0.00001) * 100) / 100;
            // console.log(percent, '%', sun_thresholds[i - 1], 'to', sun_thresholds[i], 'for i: ', i);



            // Create LERP blends of all colors between the two edge case skies
            for (let j = 0; j < num_colors; j++) {
              var start_color = new THREE.Color(sky_colors[sky_colors_keys[i - 1]][j]);
              // Even if this works it's bad and i need to fix it
              var end_color = new THREE.Color(sky_colors[sky_colors_keys[i]][j]);
              // console.log("yo", sky_colors[sky_colors_keys[i]][j]);

              var blend_color = start_color.lerpHSL(end_color, percent);

              sky_color_lerp_array.push(blend_color)

              // Update fog color if color calculated was ground (first entry in color table)
              if (j == 0) scene.fog.color = blend_color;
              if (j == 0) ambient_light.color.set(blend_color);
            }
          }
        }
        // if (sky_color_lerp_array.length != 0) console.log(sky_color_lerp_array);
        if (sky_color_lerp_array.length != 0) break;
      }
      return sky_color_lerp_array;
    }

    // Assign initial sky colors
    var blended_sky_colors = blend_sky_colors(sun_altitude, sun_thresholds, sky_colors);

    function update_colors(sky_uniforms, ground_uniforms, new_sky_colors) {
      sky_uniforms.u_ground = { value: new_sky_colors[0] },
        sky_uniforms.u_horizon = { value: new_sky_colors[1] },
        sky_uniforms.u_low = { value: new_sky_colors[2] },
        sky_uniforms.u_mid = { value: new_sky_colors[3] },
        sky_uniforms.u_upper = { value: new_sky_colors[4] },
        ground_uniforms.u_ground_glow = { value: new_sky_colors[5] }
    }

    const sky_uniforms = {
      u_ground: { value: blended_sky_colors[0] },
      u_horizon: { value: blended_sky_colors[1] },
      u_low: { value: blended_sky_colors[2] },
      u_mid: { value: blended_sky_colors[3] },
      u_upper: { value: blended_sky_colors[4] },
      u_white: { value: new THREE.Color(0xffffff) },
      u_time: { value: 0.0 },
      u_resolution: { value: { x: 0, y: 0 } }
    };

    const ground_uniforms = {
      u_ground_glow: { value: blended_sky_colors[5] },
      u_resolution: { value: { x: 0, y: 0 } }
    };

    const sky_material = new THREE.ShaderMaterial({
      uniforms: sky_uniforms,
      vertexShader: sky_vshader,
      fragmentShader: sky_fshader,
      side: THREE.BackSide,
      fog: false
    });

    const ground_material = new THREE.ShaderMaterial({
      uniforms: ground_uniforms,
      vertexShader: ground_vshader,
      fragmentShader: ground_fshader,
      fog: false,
      transparent: true
    });

    const stars_uniforms = {
      u_resolution: { value: { x: 0, y: 0 } }
    }

    const stars_material = new THREE.ShaderMaterial({
      uniforms: stars_uniforms,
      vertexShader: stars_vshader,
      fragmentShader: stars_fshader,
      // vertexColors: true;
    })

    // Objects 🔭
    var stars_geometry = new THREE.BufferGeometry();
    // var vertices = [];
    var position;

    var star_positions = [];
    var star_colors = [];
    var star_sizes = [];
    var star_mag;

    var star_color = new THREE.Color();

    for (let i = 0; i < stars_arr.length; i++) {
      position = stars_arr[i];
      // if (i == 0) alert(position);

      // vertex position: x, y, z
      star_positions.push(position[0]);
      star_positions.push(position[1]);
      star_positions.push(position[2]);

      // size (depends on visual mag, which can range from ~ -1 to 8)
      star_mag = position[4];
      // size = 5 ^ (star_mag)
      size = (8. - star_mag ^ 3) * 0.15;
      star_sizes.push(size)
    }

    stars_geometry.setAttribute('position', new THREE.Float32BufferAttribute(star_positions, 3));
    // stars_geometry.setAttribute('color', )
    stars_geometry.setAttribute('size', new THREE.Float32BufferAttribute(star_sizes, 1).setUsage(THREE.DynamicDrawUsage));

    // var stars = new THREE.Points(stars_geometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.02, fog: false }));
    var stars = new THREE.Points(stars_geometry, stars_material);
    scene.add(stars);

    var ground_geometry = new THREE.PlaneBufferGeometry(7.4, 7.4, 1, 1);
    var ground_test = new THREE.Mesh(ground_geometry, ground_material);
    ground_test.position.y = -0.01;
    ground_test.rotateX(-pi / 2);
    scene.add(ground_test);

    var sky_geometry = new THREE.SphereBufferGeometry(3.7, 50, 26);
    var sky_test = new THREE.Mesh(sky_geometry, sky_material);
    scene.add(sky_test);

    var axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    var loader = new THREE.GLTFLoader();

    var unit, mesh, clouds, sky;

    loader.load('assets/unit.glb', onLoadUnit);
    // loader.load('assets/placeholder_sky.glb', onLoadSky);
    // loader.load('assets/placeholder_ground.glb', onLoad);
    loader.load('assets/placeholder_clouds.glb', onLoadClouds);
    // loader.load('assets/lucky_cat.glb', onLoad);

    function onLoadUnit(gltf) {
      // console.log(gltf);
      unit = gltf.scene;

      scene.add(unit);
    }

    function onLoadSky(gltf) {
      // console.log(gltf);
      sky = gltf.scene;

      scene.add(sky);

      var cube_bbox = new THREE.Box3();
      cube_bbox.setFromObject(sky);
      console.log(cube_bbox.max.y - cube_bbox.min.y);
    }

    function onLoad(gltf) {
      // console.log(gltf);
      mesh = gltf.scene;
      // sky.lights = false;

      scene.add(mesh);
    }

    function onLoadClouds(gltf) {
      // console.log(gltf);
      clouds = gltf.scene;
      // sky.lights = false;

      scene.add(clouds);
    }


    // Demo input GUI 🕹

    var guiControls = new function () {
      this.RA = -40.;
      this.Dec = 95.;
      this.Latitude = 34.;
      this.Sun = sun_altitude;
      this.Cloudy = false;
      this.Axes = false;
    }

    var gui = new dat.GUI();
    gui.add(guiControls, 'RA', -180, 180);
    gui.add(guiControls, 'Dec', -180, 180);
    gui.add(guiControls, 'Latitude', 0, 90);
    gui.add(guiControls, 'Sun', -90, 90);
    gui.add(guiControls, 'Cloudy');
    gui.add(guiControls, 'Axes');


    // Resize canvas with window ↗️

    function resize_canvas_to_display_size() {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;

      if (canvas.width !== width || canvas.height !== height) {
        console.log(`canvas dimensions: ${width}x${height}`)
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        sky_uniforms.u_resolution.value.x = width;
        sky_uniforms.u_resolution.value.y = height;
        ground_uniforms.u_resolution.value.x = width;
        ground_uniforms.u_resolution.value.y = height;
      }
    }


    // Animate here 🎬

    function animate(time) {
      var time = performance.now();
      time *= 0.001; // convert ms to seconds
      sky_uniforms.u_time.value = time;

      resize_canvas_to_display_size();
      controls.update(); // damping

      // Animate unit pointing 🔭

      if (unit) {
        dec_axis = unit.getObjectByName("empty_dec", true); // aka head unit
        ra_axis = unit.getObjectByName("empty_ra", true);
        lat = unit.getObjectByName("empty_lat", true);
        mount = unit.getObjectByName("empty_mount", true);
        pier = unit.getObjectByName("empty_pier", true);

        ra_axis.rotation.x = deg_to_rad(guiControls.RA);
        dec_axis.rotation.y = deg_to_rad(guiControls.Dec);
        lat.rotation.z = deg_to_rad(guiControls.Latitude) * -1;
      }

      // Update sun position
      sun_altitude = Math.floor(guiControls.Sun * 1000) / 1000;

      stars.rotation.y = 0.00007 * time;


      if (sun_altitude != prev_sun_altitude) {
        // Update sky colors 🌅
        // Should I only try to do these sorta updates if the sun actually moved a lot (ie. some fraction of a degree)?
        update_colors(sky_uniforms, ground_uniforms, blend_sky_colors(sun_altitude, sun_thresholds, sky_colors));
        // console.log(sun_altitude);
        prev_sun_altitude = sun_altitude;
        console.log(sun_altitude);
      }
      // // ...then redraw it + change lighting too

      // Toggle clouds ☁️
      if (clouds) {
        if (guiControls.Cloudy) {
          clouds.visible = true;
          clouds.rotation.y += 0.00023;
        } else {
          clouds.visible = false;
        }
      }

      if (stars) {
        stars.rotation.z = deg_to_rad(90 - guiControls.Latitude)
      }

      // Toggle axes ✖️
      if (axesHelper) {
        if (guiControls.Axes) {
          axesHelper.visible = true;
        } else {
          axesHelper.visible = false;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);

  </script>
</body>

</html>