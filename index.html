<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>panoptes3D (Demo)</title>
  <style>
    html {
      box-sizing: border-box;
    }

    /* *,
    *:before,
    *:after {
      box-sizing: inherit;
      overflow: hidden;
    } */

    body {
      margin: 0;
      background: #3A3A3A;
      box-sizing: inherit;
      overflow: hidden;
    }

    .frame {
      /* padding: 50px; */
      display: flex;
      width: 100vw;
      height: 100vh;
      /* box-sizing: inherit;
      overflow: hidden; */
    }

    .frame>* {
      flex: 1 1 100%;
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>

  <div class="frame">
    <div class="container">
      <canvas></canvas>
    </div>
  </div>

  <script type="text/javascript" src="js/three.min.js"></script>
  <script type="text/javascript" src="js/OrbitControls.js"></script>
  <script type="text/javascript" src="js/GLTFLoader.js"></script>
  <script type="text/javascript" src="js/dat.gui.min.js"></script>
  <script type="text/javascript" src="js/RGBELoader.js"></script>

  <script type="text/javascript">

    console.log(`using three.js r${THREE.REVISION}`);

    const pi = Math.PI;

    function deg_to_rad(deg) {
      return deg * pi / 180;
    }

    // Shaders üîÆ
    const sky_vshader = `
    varying vec2 v_uv;

    void main() {
      v_uv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
    `

    const sky_fshader = `
    uniform vec2 u_resolution;
    uniform float u_time;
    uniform vec3 u_ground;
    uniform vec3 u_horizon;
    uniform vec3 u_low1;
    uniform vec3 u_low2;
    uniform vec3 u_mid;
    uniform vec3 u_upper;
    uniform vec3 u_white;
    varying vec2 v_uv;

    void main (void) {
      // vec2 uv = gl_FragCoord.xy/u_resolution;
      
      // Mix from the ground up.
      vec3 mix1 = mix(u_ground, u_horizon, smoothstep(0.5, 0.6, v_uv.y));
      vec3 mix2 = mix(mix1, u_low1, smoothstep(0.5, 0.7, v_uv.y));
      vec3 mix3 = mix(mix2, u_low2, smoothstep(0.4, 1.0, v_uv.y));
      vec3 mix4 = mix(mix3, u_mid, smoothstep(0.5, 1., v_uv.y));
      vec3 mix5 = mix(mix4, u_upper, smoothstep(0.6, 1., v_uv.y));
      // vec3 mix6 = mix(mix5, u_mid, smoothstep(0.5, 0.1, v_uv.y));
      // vec3 mix6 = mix(mix5, u_white, smoothstep(0.7, 1., v_uv.y));
      // vec3 mix6 = vec3(0.0);

      // vec3 color = vec3(v_uv.x, v_uv.y, 0.0);
      gl_FragColor = vec4(mix5, 1.0);
    }
    `

    // FPS stats (by mrdoob) üìä

    javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'http://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })()

    // Camera settings üé•

    const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector("canvas"), alpha: true, antialias: true });
    renderer.outputEncoding = THREE.sRGBEncoding;
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
    // camera.position.set(15, 3, 15);
    camera.position.set(50, 3, 50);
    // controls = new THREE.PointerLockControls(camera, renderer.domElement);
    var controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 3, 0);
    controls.enablePan = false;
    controls.update();


    // Scene setup üñº

    const scene = new THREE.Scene();
    // { scene.fog = new THREE.Fog(0x7ce6d9, 30, 350); }


    // Lighting üí°

    const light1 = new THREE.PointLight(0xffcfa6, 0.25, 0);
    light1.position.set(10, 10, 10);
    scene.add(light1);

    const light2 = new THREE.PointLight(0xffcfa6, 0.25, 0);
    light2.position.set(-10, 10, -10);
    scene.add(light2);

    // var directionalLight = new THREE.DirectionalLight(0xffffff, 2);
    // scene.add(directionalLight);

    var light = new THREE.AmbientLight(0xbfa6ff, intensity = 0.65);
    scene.add(light);


    // Sun altitude



    // HDRI üåá
    var pmremGenerator = new THREE.PMREMGenerator(renderer);
    new THREE.RGBELoader()
      .setDataType(THREE.UnsignedByteType)
      .setPath('assets/hdri/')
      .load('placeholder_sunset.hdr', function (texture) {

        var envMap = pmremGenerator.fromEquirectangular(texture).texture;
        pmremGenerator.compileCubemapShader();

        // scene.background = envMap;
        scene.environment = envMap;

        texture.dispose();
        pmremGenerator.dispose();

      });


    // Materials üé®
    const uniforms = {
      u_ground: { value: new THREE.Color(0x5f9df3) },
      u_horizon: { value: new THREE.Color(0xad9ed6) },
      u_low1: { value: new THREE.Color(0xe4ffee) },
      u_low2: { value: new THREE.Color(0x6ccaff) },
      u_mid: { value: new THREE.Color(0x6ccaff) },
      u_upper: { value: new THREE.Color(0x557feb) },
      u_white: { value: new THREE.Color(0xffffff) },
      u_time: { value: 0.0 },
      u_resolution: { value: { x: 0, y: 0 } }
    }

    const sky_material = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: sky_vshader,
      fragmentShader: sky_fshader,
      side: THREE.BackSide
    });


    // Objects üî≠

    var sky_geometry = new THREE.SphereGeometry(18.47, 25, 20);
    var sky_test = new THREE.Mesh(sky_geometry, sky_material);
    scene.add(sky_test);

    var axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    var loader = new THREE.GLTFLoader();

    var unit, mesh, clouds, sky;

    loader.load('assets/unit.glb', onLoadUnit);
    // loader.load('assets/placeholder_sky.glb', onLoadSky);
    // loader.load('assets/placeholder_ground.glb', onLoad);
    loader.load('assets/placeholder_clouds.glb', onLoadClouds);

    function onLoadUnit(gltf) {
      // console.log(gltf);
      unit = gltf.scene;

      scene.add(unit);
    }

    function onLoadSky(gltf) {
      // console.log(gltf);
      sky = gltf.scene;

      scene.add(sky);

      var cube_bbox = new THREE.Box3();
      cube_bbox.setFromObject(sky);
      console.log(cube_bbox.max.y - cube_bbox.min.y);
    }

    function onLoad(gltf) {
      // console.log(gltf);
      mesh = gltf.scene;
      // sky.lights = false;

      scene.add(mesh);
    }

    function onLoadClouds(gltf) {
      // console.log(gltf);
      clouds = gltf.scene;
      // sky.lights = false;

      scene.add(clouds);
    }


    // Demo input GUI¬†üïπ

    var guiControls = new function () {
      this.RA = -40.;
      this.Dec = 95.;
      this.Latitude = 34.;
      this.Sun = 60.;
      this.Cloudy = false;
      this.Axes = false;
    }

    var gui = new dat.GUI();
    gui.add(guiControls, 'RA', -180, 180);
    gui.add(guiControls, 'Dec', -180, 180);
    gui.add(guiControls, 'Latitude', 0, 90);
    gui.add(guiControls, 'Sun', -90, 90);
    gui.add(guiControls, 'Cloudy');
    gui.add(guiControls, 'Axes');


    // Resize canvas with window ‚ÜóÔ∏è

    function resizeCanvasToDisplaySize() {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;

      if (canvas.width !== width || canvas.height !== height) {
        console.log(`canvas dimensions: ${width}x${height}`)
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        uniforms.u_resolution.value.x = width;
        uniforms.u_resolution.value.y = height;
      }
    }


    // Animate here üé¨

    function animate(time) {
      var time = performance.now();
      time *= 0.001; // convert ms to seconds
      uniforms.u_time.value = time;

      resizeCanvasToDisplaySize();

      // Animate unit pointing üî≠

      if (unit) {
        dec_axis = unit.getObjectByName("empty_dec", true); // aka head unit
        ra_axis = unit.getObjectByName("empty_ra", true);
        lat = unit.getObjectByName("empty_lat", true);
        mount = unit.getObjectByName("empty_mount", true);
        pier = unit.getObjectByName("empty_pier", true);

        ra_axis.rotation.x = deg_to_rad(guiControls.RA);
        dec_axis.rotation.y = deg_to_rad(guiControls.Dec);
        lat.rotation.z = deg_to_rad(guiControls.Latitude) * -1;
      }

      // Toggle clouds ‚òÅÔ∏è
      if (clouds) {
        if (guiControls.Cloudy) {
          clouds.visible = true;
          clouds.rotation.y += 0.0003;
        } else {
          clouds.visible = false;
        }
      }

      // Toggle axes ‚úñÔ∏è
      if (axesHelper) {
        if (guiControls.Axes) {
          axesHelper.visible = true;
        } else {
          axesHelper.visible = false;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);

  </script>
</body>

</html>